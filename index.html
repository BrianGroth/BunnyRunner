<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Endless Runner: Rabbit Emoji Adventure - Vertical</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #eef;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
</head>
<body>
  <!-- Background canvas: sky, clouds, and parallax hills -->
  <canvas id="bgCanvas"></canvas>
  <!-- Game canvas: rabbit, falling items, and UI -->
  <canvas id="gameCanvas"></canvas>

  <script>
    // Canvas setup.
    const bgCanvas = document.getElementById("bgCanvas");
    const bgCtx = bgCanvas.getContext("2d");
    const gameCanvas = document.getElementById("gameCanvas");
    const ctx = gameCanvas.getContext("2d");

    // Global game state.
    let initialScore = 10;
    let score = initialScore;
    let difficulty = 0; // gradually increases falling speed
    let gameStarted = false;
    let gameOver = false;
    let spawnTimer = 0;
    let outchTimer = 0; // frames to show "outch" when hit
    let bgOffset = 0; // used for parallax scrolling

    // Dimensions and ground.
    let groundY;
    const rabbitSize = 50;
    let rabbit = {
      x: 0, // set in resize() to horizontal center
      y: 0, // set in resize() so that it rests on the ground
      size: rabbitSize,
      velocityY: 0,
      jumpForce: -12,
      gravity: 0.5,
      animCounter: 0,
      animFrame: 0  // toggles between 0 and 1 for simple animation
    };

    let items = []; // falling items: food and obstacles

    // Clouds for a creative sky.
    let clouds = [];
    function initClouds() {
      clouds = [];
      for (let i = 0; i < 5; i++) {
        let x = Math.random() * bgCanvas.width;
        let y = Math.random() * (bgCanvas.height / 2);
        let speed = 0.3 + Math.random() * 0.7;
        clouds.push({ x, y, speed });
      }
    }

    // Resize canvases and reposition elements.
    function resize() {
      bgCanvas.width = window.innerWidth;
      bgCanvas.height = window.innerHeight;
      gameCanvas.width = window.innerWidth;
      gameCanvas.height = window.innerHeight;
      groundY = gameCanvas.height - 50;
      // Position rabbit in the center-bottom.
      rabbit.x = gameCanvas.width / 2 - rabbit.size / 2;
      rabbit.y = groundY - rabbit.size;
      initClouds();
    }
    window.addEventListener("resize", resize);
    resize();

    // Spawn a falling item from the top.
    function spawnItem() {
      let type = Math.random() < 0.6 ? 'food' : 'obstacle';
      let emoji = '';
      if (type === 'food') {
        const foods = ['🍎', '🍌', '🍇', '🍉', '🍓', '🍊', '🥕', '🥦'];
        emoji = foods[Math.floor(Math.random() * foods.length)];
      } else {
        const obstacles = ['🌳', '🪨'];
        emoji = obstacles[Math.floor(Math.random() * obstacles.length)];
      }
      let x = Math.random() * (gameCanvas.width - 40); // random x position
      let y = -40; // spawn just above the top
      let size = 40;
      let baseSpeed = 3;
      let speed = baseSpeed + difficulty;
      items.push({ type, emoji, x, y, size, speed });
    }

    // Update game state.
    function update() {
      if (gameOver) {
        if (outchTimer > 0) outchTimer--;
        // Keep background scrolling.
        bgOffset += 1;
        return;
      }

      if (gameStarted) {
        difficulty += 0.005; // gradually increase difficulty
      }

      bgOffset += 1; // update background offset for parallax

      // Update rabbit physics.
      rabbit.velocityY += rabbit.gravity;
      rabbit.y += rabbit.velocityY;
      if (rabbit.y > groundY - rabbit.size) {
        rabbit.y = groundY - rabbit.size;
        rabbit.velocityY = 0;
      }
      // Rabbit animation: toggle every 15 frames.
      rabbit.animCounter++;
      if (rabbit.animCounter > 15) {
        rabbit.animFrame = (rabbit.animFrame + 1) % 2;
        rabbit.animCounter = 0;
      }

      // Update clouds (drifting downward).
      clouds.forEach(cloud => {
        cloud.y += cloud.speed;
        if (cloud.y > bgCanvas.height + 30) {
          cloud.y = -30;
          cloud.x = Math.random() * bgCanvas.width;
        }
      });

      // Update falling items.
      for (let i = items.length - 1; i >= 0; i--) {
        let item = items[i];
        item.y += item.speed;
        // Collision detection.
        if (
          item.x < rabbit.x + rabbit.size &&
          item.x + item.size > rabbit.x &&
          item.y < rabbit.y + rabbit.size &&
          item.y + item.size > rabbit.y
        ) {
          if (item.type === 'food') {
            score += 1;
          } else {
            score -= 1;
            outchTimer = 30;
          }
          items.splice(i, 1);
          if (score <= 0) {
            score = 0;
            gameOver = true;
          }
        } else if (item.y > gameCanvas.height) {
          items.splice(i, 1);
        }
      }

      // Spawn new items based on difficulty.
      let spawnInterval = Math.max(30, 90 - Math.floor(difficulty * 10));
      spawnTimer++;
      if (spawnTimer > spawnInterval) {
        spawnItem();
        spawnTimer = 0;
      }
    }

    // Draw the parallax background.
    function drawBackground() {
      bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
      // Sky gradient.
      let gradient = bgCtx.createLinearGradient(0, 0, 0, bgCanvas.height);
      gradient.addColorStop(0, "#aee");
      gradient.addColorStop(1, "#ccf");
      bgCtx.fillStyle = gradient;
      bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

      // Draw distant hills (parallax layer).
      let hillHeight = 100;
      bgCtx.fillStyle = "#8c8";
      // Draw hills across the width.
      for (let i = -1; i < 2; i++) {
        bgCtx.beginPath();
        let startX = i * gameCanvas.width / 2;
        bgCtx.moveTo(startX, groundY);
        bgCtx.quadraticCurveTo(
          startX + gameCanvas.width / 4,
          groundY - hillHeight,
          startX + gameCanvas.width / 2,
          groundY
        );
        bgCtx.fill();
      }

      // Draw drifting clouds.
      bgCtx.font = "30px sans-serif";
      clouds.forEach(cloud => {
        bgCtx.fillText("☁️", cloud.x, cloud.y);
      });

      // Draw ground.
      bgCtx.fillStyle = "#654321";
      bgCtx.fillRect(0, groundY, bgCanvas.width, bgCanvas.height - groundY);
    }

    // Draw game objects and UI.
    function drawGame() {
      ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

      // Draw falling items.
      items.forEach(item => {
        ctx.font = item.size + "px sans-serif";
        ctx.fillText(item.emoji, item.x, item.y + item.size);
      });

      // Draw the animated rabbit.
      ctx.font = rabbit.size + "px sans-serif";
      let rabbitEmoji = (rabbit.animFrame === 0) ? "🐰" : "🐇";
      ctx.fillText(rabbitEmoji, rabbit.x, rabbit.y + rabbit.size);

      // Display "outch" if recently hit.
      if (outchTimer > 0) {
        ctx.font = "20px sans-serif";
        ctx.fillStyle = "red";
        ctx.fillText("outch", rabbit.x, rabbit.y - 10);
      }

      // Show score.
      ctx.font = "24px sans-serif";
      ctx.fillStyle = "#000";
      ctx.fillText("Score: " + score, 10, 30);

      // Pre-game instructions overlay.
      if (!gameStarted && !gameOver) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
        ctx.font = "30px sans-serif";
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText("Tap to start and jump!", gameCanvas.width / 2, gameCanvas.height / 2);
        ctx.textAlign = "start";
      }

      // Game Over screen.
      if (gameOver) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
        ctx.font = "40px sans-serif";
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText("Game Over", gameCanvas.width / 2, gameCanvas.height / 2 - 20);
        ctx.font = "30px sans-serif";
        ctx.fillText("Tap to Restart", gameCanvas.width / 2, gameCanvas.height / 2 + 20);
        ctx.textAlign = "start";
      }
    }

    // Main game loop.
    function gameLoop() {
      update();
      drawBackground();
      drawGame();
      requestAnimationFrame(gameLoop);
    }
    gameLoop();

    // On tap/click: jump or restart.
    function jumpOrRestart() {
      if (gameOver) {
        restartGame();
        return;
      }
      if (!gameStarted) {
        gameStarted = true;
      }
      // Jump if on ground.
      if (rabbit.y >= groundY - rabbit.size - 1) {
        rabbit.velocityY = rabbit.jumpForce;
      }
    }

    // Reset game state.
    function restartGame() {
      score = initialScore;
      difficulty = 0;
      gameStarted = false;
      gameOver = false;
      spawnTimer = 0;
      items = [];
      rabbit.x = gameCanvas.width / 2 - rabbit.size / 2;
      rabbit.y = groundY - rabbit.size;
      rabbit.velocityY = 0;
      outchTimer = 0;
      bgOffset = 0;
      initClouds();
    }

    // Listen for tap/click events.
    gameCanvas.addEventListener("touchstart", function(e) {
      e.preventDefault();
      jumpOrRestart();
    });
    gameCanvas.addEventListener("mousedown", jumpOrRestart);

    // Allow horizontal movement by dragging.
    function moveRabbit(e) {
      let clientX = (e.touches && e.touches.length > 0) ? e.touches[0].clientX : e.clientX;
      rabbit.x = clientX - rabbit.size / 2;
      // Constrain within canvas.
      if (rabbit.x < 0) rabbit.x = 0;
      if (rabbit.x > gameCanvas.width - rabbit.size) rabbit.x = gameCanvas.width - rabbit.size;
    }
    gameCanvas.addEventListener("touchmove", function(e) {
      e.preventDefault();
      moveRabbit(e);
    });
    gameCanvas.addEventListener("mousemove", moveRabbit);
  </script>
</body>
</html>